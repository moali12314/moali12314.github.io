<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Soul Knight Base</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: none; width: 100%; height: 100%; }
        #orientationMessage {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            color: white;
            font-size: 24px;
            text-align: center;
            background: black;
            z-index: 1000;
        }
        #rotateButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="orientationMessage">Переверните устройство в горизонтальное положение для игры.</div>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageDiv = document.getElementById('orientationMessage');

        // Проверка мобильного устройства
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Размеры
        let SCREEN_WIDTH = window.innerWidth;
        let SCREEN_HEIGHT = window.innerHeight;

        // Загрузка изображений откладывается
        let mapImg, charImg, mapLoaded = false, charLoaded = false;
        let MAP_WIDTH = 800, MAP_HEIGHT = 600;
        let charWidth = 50, charHeight = 50;

        // Позиция персонажа
        let charX, charY;
        const charSpeed = 5;

        // Камера
        let cameraX = 0, cameraY = 0;

        // Клавиши
        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        // Джойстик
        let joystickActive = false;
        const joystickRadius = 50;
        let joystickCenter = { x: 100, y: SCREEN_HEIGHT - 100 };
        let joystickPos = { x: 0, y: 0 };
        let touchId = null;

        // Проверка ориентации с принуждением
        async function checkOrientation(andStartGame = false) {
            SCREEN_WIDTH = window.innerWidth;
            SCREEN_HEIGHT = window.innerHeight;
            canvas.width = SCREEN_WIDTH;
            canvas.height = SCREEN_HEIGHT;
            joystickCenter.y = SCREEN_HEIGHT - 100;

            const isLandscape = SCREEN_WIDTH > SCREEN_HEIGHT;

            if (!isMobile) {
                messageDiv.style.display = 'none';
                canvas.style.display = 'block';
                if (andStartGame) await startGame();
                return;
            }

            // Принуждение: показываем надпись всегда в portrait, скрываем в landscape
            if (isLandscape) {
                messageDiv.style.display = 'none';
                canvas.style.display = 'block';
                // Автоматический lock в landscape
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
                            await document.documentElement.requestFullscreen();
                        }
                        await screen.orientation.lock('landscape');
                    } catch (err) {}
                }
                if (andStartGame) await startGame();
            } else {
                messageDiv.style.display = 'flex';
                canvas.style.display = 'none';
                if (!document.getElementById('rotateButton')) {
                    const button = document.createElement('button');
                    button.id = 'rotateButton';
                    button.textContent = 'Перевернуть';
                    button.onclick = async () => {
                        if (document.documentElement.requestFullscreen) {
                            await document.documentElement.requestFullscreen().catch(() => {});
                        }
                        if (screen.orientation && screen.orientation.lock) {
                            screen.orientation.lock('landscape').catch(() => {});
                        }
                        // Повторная проверка после клика
                        setTimeout(() => checkOrientation(true), 500);
                    };
                    messageDiv.appendChild(button);
                }
            }
        }

        // Старт игры только в landscape
        async function startGame() {
            if (mapLoaded && charLoaded) return; // Не загружать повторно

            // Загрузка изображений (одинаковая для ПК и мобильных)
            mapImg = new Image();
            mapImg.src = 'map.png'; // Измени здесь на своё изображение карты (одинаковое для всех)
            await new Promise(resolve => {
                mapImg.onload = () => {
                    mapLoaded = true;
                    MAP_WIDTH = mapImg.width;
                    MAP_HEIGHT = mapImg.height;
                    resolve();
                };
                mapImg.onerror = () => {
                    resolve(); // Fallback
                };
            });

            charImg = new Image();
            charImg.src = 'character.png'; // Измени здесь на своё изображение персонажа
            await new Promise(resolve => {
                charImg.onload = () => {
                    charLoaded = true;
                    charWidth = charImg.width;
                    charHeight = charImg.height;
                    resolve();
                };
                charImg.onerror = () => {
                    resolve(); // Fallback
                };
            });

            charX = MAP_WIDTH / 2 - charWidth / 2;
            charY = MAP_HEIGHT / 2 - charHeight / 2;

            // Touch events для джойстика (с e.preventDefault внутри)
            if (isMobile) {
                canvas.addEventListener('touchstart', handleTouchStart);
                canvas.addEventListener('touchmove', handleTouchMove);
                canvas.addEventListener('touchend', handleTouchEnd);
            }

            gameLoop();
        }

        // Touch handlers с preventDefault
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            const dist = Math.hypot(touchX - joystickCenter.x, touchY - joystickCenter.y);
            if (dist <= joystickRadius * 2 && !joystickActive) {
                joystickActive = true;
                joystickPos.x = touchX;
                joystickPos.y = touchY;
                touchId = touch.identifier;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (joystickActive) {
                for (let touch of e.touches) {
                    if (touch.identifier === touchId) {
                        const rect = canvas.getBoundingClientRect();
                        joystickPos.x = touch.clientX - rect.left;
                        joystickPos.y = touch.clientY - rect.top;
                        break;
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            joystickActive = false;
            touchId = null;
        }

        // Игровой цикл
        function gameLoop() {
            // Движение
            if (keys['w']) charY -= charSpeed;
            if (keys['s']) charY += charSpeed;
            if (keys['a']) charX -= charSpeed;
            if (keys['d']) charX += charSpeed;

            if (isMobile && joystickActive) {
                let dx = joystickPos.x - joystickCenter.x;
                let dy = joystickPos.y - joystickCenter.y;
                let dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    dx /= dist;
                    dy /= dist;
                    if (dist > joystickRadius) dist = joystickRadius;
                    charX += dx * charSpeed * (dist / joystickRadius);
                    charY += dy * charSpeed * (dist / joystickRadius);
                }
            }

            // Ограничения
            charX = Math.max(0, Math.min(charX, MAP_WIDTH - charWidth));
            charY = Math.max(0, Math.min(charY, MAP_HEIGHT - charHeight));

            // Камера
            let desiredCameraX = charX + charWidth / 2 - SCREEN_WIDTH / 2;
            let desiredCameraY = charY + charHeight / 2 - SCREEN_HEIGHT / 2;
            cameraX = MAP_WIDTH > SCREEN_WIDTH ? Math.max(0, Math.min(desiredCameraX, MAP_WIDTH - SCREEN_WIDTH)) : 0;
            cameraY = MAP_HEIGHT > SCREEN_HEIGHT ? Math.max(0, Math.min(desiredCameraY, MAP_HEIGHT - SCREEN_HEIGHT)) : 0;

            // Оффсет для центрирования (без масштабирования, чтобы карта была одинаковой)
            const offsetX = MAP_WIDTH < SCREEN_WIDTH ? (SCREEN_WIDTH - MAP_WIDTH) / 2 : 0;
            const offsetY = MAP_HEIGHT < SCREEN_HEIGHT ? (SCREEN_HEIGHT - MAP_HEIGHT) / 2 : 0;

            // Отрисовка
            ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            const mapDrawX = offsetX - cameraX;
            const mapDrawY = offsetY - cameraY;
            if (mapLoaded) {
                ctx.drawImage(mapImg, mapDrawX, mapDrawY, MAP_WIDTH, MAP_HEIGHT);
            } else {
                ctx.fillStyle = 'gray';
                ctx.fillRect(mapDrawX, mapDrawY, MAP_WIDTH, MAP_HEIGHT);
            }

            const screenCharX = charX + offsetX - cameraX;
            const screenCharY = charY + offsetY - cameraY;
            if (charLoaded) {
                ctx.drawImage(charImg, screenCharX, screenCharY, charWidth, charHeight);
            } else {
                ctx.fillStyle = 'red';
                ctx.fillRect(screenCharX, screenCharY, charWidth, charHeight);
            }

            // Джойстик
            if (isMobile && joystickActive) {
                ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                ctx.beginPath();
                ctx.arc(joystickCenter.x, joystickCenter.y, joystickRadius * 2, 0, Math.PI * 2);
                ctx.fill();

                let dx = joystickPos.x - joystickCenter.x;
                let dy = joystickPos.y - joystickCenter.y;
                let dist = Math.hypot(dx, dy);
                if (dist > joystickRadius) {
                    dx = dx / dist * joystickRadius;
                    dy = dy / dist * joystickRadius;
                }
                ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.beginPath();
                ctx.arc(joystickCenter.x + dx, joystickCenter.y + dy, joystickRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            requestAnimationFrame(gameLoop);
        }

        // Инициализация
        window.addEventListener('resize', () => checkOrientation(true));
        window.addEventListener('orientationchange', () => checkOrientation(true));
        checkOrientation(true);
    </script>
</body>
</html>
