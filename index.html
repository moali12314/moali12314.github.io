<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Soul Knight - Боец подземелий</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: #000;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: pan-y pinch-zoom;
        }
        @media (max-width: 768px) and (orientation: portrait) {
            body::before {
                content: "ПОВЕРНИТЕ ЭКРАН";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: white;
                font-size: 24px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                z-index: 9999;
                font-family: 'Arial', sans-serif;
                letter-spacing: 4px;
                text-shadow: 0 0 10px rgba(255,255,255,0.5);
                border: 4px solid #fff;
            }
            canvas, #joystickZone {
                display: none !important;
            }
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        #joystickZone {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            z-index: 100;
            border-radius: 50%;
            background: rgba(30, 30, 40, 0.7);
            backdrop-filter: blur(8px);
            border: 3px solid rgba(255, 215, 0, 0.6);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            display: block;
            touch-action: none;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="joystickZone"></div>

    <script>
        (function() {
            // Telegram Web App
            if (window.Telegram?.WebApp) {
                Telegram.WebApp.ready();
                Telegram.WebApp.expand();
                Telegram.WebApp.setHeaderColor?.('#000000');
                Telegram.WebApp.setBottomBarColor?.('#000000');
            }

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            // ==============================================
            // НАСТРОЙКИ
            // ==============================================
            const TILE_SIZE = 64;
            const IDLE_WIDTH  = 48;
            const IDLE_HEIGHT = 64;
            const RUN_WIDTH   = 56;
            const RUN_HEIGHT  = 64;

            const WORLD_WIDTH  = 30;
            const WORLD_HEIGHT = 15;

            const WORLD_PIXEL_WIDTH  = WORLD_WIDTH  * TILE_SIZE;
            const WORLD_PIXEL_HEIGHT = WORLD_HEIGHT * TILE_SIZE;

            let canvasWidth, canvasHeight;

            // Пути к спрайтам (замени на свои файлы)
            const PLAYER_IDLE_IMAGE = 'baserun.png';
            const PLAYER_RUN1_IMAGE = 'run1.png';
            const PLAYER_RUN2_IMAGE = 'run2.png';
            const PLAYER_RUN3_IMAGE = 'run3.png';

            const playerImages = {
                idle: new Image(),
                run: [new Image(), new Image(), new Image()]
            };

            function loadImage(src, imgElement) {
                return new Promise((resolve) => {
                    imgElement.onload = resolve;
                    imgElement.onerror = () => {
                        console.error('Ошибка загрузки:', src);
                        const c = document.createElement('canvas');
                        c.width = c.height = 64;
                        const ct = c.getContext('2d');
                        ct.fillStyle = '#FF4444';
                        ct.fillRect(0,0,64,64);
                        imgElement.src = c.toDataURL();
                        resolve();
                    };
                    imgElement.src = src;
                });
            }

            Promise.all([
                loadImage(PLAYER_IDLE_IMAGE, playerImages.idle),
                loadImage(PLAYER_RUN1_IMAGE, playerImages.run[0]),
                loadImage(PLAYER_RUN2_IMAGE, playerImages.run[1]),
                loadImage(PLAYER_RUN3_IMAGE, playerImages.run[2])
            ]);

            let player = {
                x: (WORLD_PIXEL_WIDTH - IDLE_WIDTH) / 2,
                y: (WORLD_PIXEL_HEIGHT - IDLE_HEIGHT) / 2,
                vx: 0,
                vy: 0,
                speed: 1.2,
                facing: 1,
                width: IDLE_WIDTH,
                height: IDLE_HEIGHT,
                isMoving: false
            };

            let animationFrame = 0;
            const ANIMATION_SPEED = 6;
            let frameCounter = 0;

            function getTileType(x, y) {
                const noise1 = Math.sin(x * 0.2) * Math.cos(y * 0.2);
                const noise2 = Math.sin(x * 0.1 + 2) * Math.cos(y * 0.15 + 1);
                const combined = noise1 * 0.7 + noise2 * 0.3;
                if (combined > 0.4) return 'grass';
                if (combined < -0.3) return 'water';
                if (Math.abs(combined) < 0.1) return 'path';
                return 'dirt';
            }

            const TILE_COLORS = {
                grass: '#4A7C59',
                dirt:  '#8B7355',
                water: '#4A90E2',
                path:  '#C0A080'
            };

            function drawBackground() {
                const grad = ctx.createLinearGradient(0, 0, 0, WORLD_PIXEL_HEIGHT);
                grad.addColorStop(0,   '#1a1f2e');
                grad.addColorStop(0.3, '#2a2f3e');
                grad.addColorStop(0.7, '#1f2a2f');
                grad.addColorStop(1,   '#152025');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, WORLD_PIXEL_WIDTH, WORLD_PIXEL_HEIGHT);

                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        const type = getTileType(x, y);
                        ctx.fillStyle = TILE_COLORS[type];
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            function drawPlayer() {
                let currentImage;
                let currentWidth, currentHeight;

                if (player.isMoving) {
                    currentWidth = RUN_WIDTH;
                    currentHeight = RUN_HEIGHT;
                    frameCounter++;
                    if (frameCounter >= ANIMATION_SPEED) {
                        frameCounter = 0;
                        animationFrame = (animationFrame + 1) % 3;
                    }
                    currentImage = playerImages.run[animationFrame];
                } else {
                    currentWidth = IDLE_WIDTH;
                    currentHeight = IDLE_HEIGHT;
                    currentImage = playerImages.idle;
                }

                player.width = currentWidth;
                player.height = currentHeight;

                ctx.save();

                if (currentImage && currentImage.complete && currentImage.naturalHeight !== 0) {
                    if (player.facing === -1) {
                        ctx.translate(player.x + currentWidth, player.y);
                        ctx.scale(-1, 1);
                        ctx.drawImage(currentImage, 0, 0, currentWidth, currentHeight);
                    } else {
                        ctx.drawImage(currentImage, player.x, player.y, currentWidth, currentHeight);
                    }
                } else {
                    ctx.fillStyle = '#FF4444';
                    ctx.fillRect(player.x, player.y, currentWidth, currentHeight);
                }

                ctx.restore();
            }

            function update() {
                const currentWidth  = player.isMoving ? RUN_WIDTH  : IDLE_WIDTH;
                const currentHeight = player.isMoving ? RUN_HEIGHT : IDLE_HEIGHT;

                player.x += player.vx;
                player.y += player.vy;

                player.x = Math.max(0, Math.min(WORLD_PIXEL_WIDTH - currentWidth, player.x));
                player.y = Math.max(0, Math.min(WORLD_PIXEL_HEIGHT - currentHeight, player.y));

                player.vx *= 0.85;
                player.vy *= 0.85;
                if (Math.abs(player.vx) < 0.1) player.vx = 0;
                if (Math.abs(player.vy) < 0.1) player.vy = 0;

                const wasMoving = player.isMoving;
                player.isMoving = (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1);

                if (player.vx !== 0) player.facing = player.vx > 0 ? 1 : -1;

                // Корректировка центра при смене анимации
                if (wasMoving && !player.isMoving) {
                    const centerX = player.x + RUN_WIDTH / 2;
                    player.x = centerX - IDLE_WIDTH / 2;
                    player.x = Math.max(0, Math.min(WORLD_PIXEL_WIDTH - IDLE_WIDTH, player.x));
                    animationFrame = 0;
                    frameCounter = 0;
                }
                if (!wasMoving && player.isMoving) {
                    const centerX = player.x + IDLE_WIDTH / 2;
                    player.x = centerX - RUN_WIDTH / 2;
                    player.x = Math.max(0, Math.min(WORLD_PIXEL_WIDTH - RUN_WIDTH, player.x));
                }
            }

            // ────────────────────────────────────────────────
            // Клавиатура
            // ────────────────────────────────────────────────
            const keys = {};
            document.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(e.key.toLowerCase())) {
                    e.preventDefault();
                }
            });
            document.addEventListener('keyup', e => {
                keys[e.key.toLowerCase()] = false;
            });

            function handleKeyboard() {
                let dx = 0, dy = 0;
                if (keys['a'] || keys['arrowleft']) dx -= 1;
                if (keys['d'] || keys['arrowright']) dx += 1;
                if (keys['w'] || keys['arrowup']) dy -= 1;
                if (keys['s'] || keys['arrowdown']) dy += 1;

                if (dx || dy) {
                    const len = Math.sqrt(dx*dx + dy*dy);
                    const targetSpeed = player.speed * 4;
                    player.vx = (dx / len) * targetSpeed;
                    player.vy = (dy / len) * targetSpeed;
                }
            }

            // ────────────────────────────────────────────────
            // Джойстик
            // ────────────────────────────────────────────────
            let joystick = null;
            const joystickZone = document.getElementById('joystickZone');

            function initJoystick() {
                if (joystick) joystick.destroy();
                if (typeof nipplejs !== 'undefined') {
                    joystick = nipplejs.create({
                        zone: joystickZone,
                        mode: 'static',
                        position: { left: '50%', bottom: '50%' },
                        color: 'white',
                        size: 120,
                        threshold: 0.1
                    });

                    joystick.on('move', (evt, data) => {
                        if (data.vector) {
                            const targetSpeed = player.speed * 4;
                            player.vx = data.vector.x * targetSpeed;
                            player.vy = -data.vector.y * targetSpeed;
                        }
                    });

                    joystick.on('end', () => {
                        player.vx = player.vy = 0;
                    });
                }
            }

            function resizeCanvas() {
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
            }

            function checkOrientation() {
                if (window.innerWidth < window.innerHeight && window.innerWidth <= 768) {
                    return false;
                }
                return true;
            }

            function init() {
                resizeCanvas();
                if (!checkOrientation()) return;
                initJoystick();
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    if (checkOrientation()) initJoystick();
                });
                gameLoop();
                setInterval(handleKeyboard, 16);
            }

            function gameLoop() {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                const scale = Math.min(
                    canvasWidth / WORLD_PIXEL_WIDTH,
                    canvasHeight / WORLD_PIXEL_HEIGHT
                ) * 0.95;

                const offsetX = (canvasWidth  - WORLD_PIXEL_WIDTH  * scale) / 2;
                const offsetY = (canvasHeight - WORLD_PIXEL_HEIGHT * scale) / 2;

                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);

                drawBackground();
                update();
                drawPlayer();

                ctx.restore();

                requestAnimationFrame(gameLoop);
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        })();
    </script>
</body>
</html>
