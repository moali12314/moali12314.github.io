<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Soul Knight - Horizontal Fullscreen</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: #000;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: pan-y pinch-zoom;
        }

        @media (max-width: 768px) and (orientation: portrait) {
            body::before {
                content: "ПОВЕРНИТЕ ЭКРАН";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: white;
                font-size: 24px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                z-index: 9999;
                font-family: Arial, sans-serif;
                letter-spacing: 2px;
            }
            canvas, #joystickZone {
                display: none !important;
            }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: fill;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        #joystickZone {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 130px;
            height: 130px;
            z-index: 100;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(4px);
            border: 2px solid rgba(255,255,255,0.3);
            display: block;
            touch-action: none;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="joystickZone"></div>

    <script>
        (function() {
            // Telegram Web App
            if (window.Telegram?.WebApp) {
                Telegram.WebApp.ready();
                Telegram.WebApp.expand();
                Telegram.WebApp.setHeaderColor?.('#000000');
            }

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            // ==============================================
            // НАСТРОЙКИ РАЗМЕРОВ ПЕРСОНАЖА
            // ==============================================
            // Размер тайла (базовая единица измерения для мира)
            const TILE_SIZE = 16;

            // РАЗМЕРЫ СТОЯЧЕГО ПЕРСОНАЖА (IDLE)
            const IDLE_WIDTH = 32;     // Ширина в покое
            const IDLE_HEIGHT = 48;    // Высота в покое

            // РАЗМЕРЫ БЕГУЩЕГО ПЕРСОНАЖА (RUN)
            const RUN_WIDTH = 40;       // Ширина при беге
            const RUN_HEIGHT = 48;      // Высота при беге

            // Примеры других вариантов:
            // Приземистый бег: RUN_WIDTH = 48, RUN_HEIGHT = 32
            // Вытянутый бег: RUN_WIDTH = 48, RUN_HEIGHT = 56
            // Широкий бег: RUN_WIDTH = 64, RUN_HEIGHT = 48
            // ==============================================

            // Размеры мира (в тайлах)
            const WORLD_WIDTH = 40;
            const WORLD_HEIGHT = 20;

            // Мир в пикселях
            const WORLD_PIXEL_WIDTH = WORLD_WIDTH * TILE_SIZE;
            const WORLD_PIXEL_HEIGHT = WORLD_HEIGHT * TILE_SIZE;

            // Переменные для размеров canvas
            let canvasWidth, canvasHeight;

            // ==============================================
            // ПУТИ К ФОТОГРАФИЯМ ПЕРСОНАЖА
            // ==============================================
            const PLAYER_IDLE_IMAGE = 'baserun.png';
            const PLAYER_RUN1_IMAGE = 'run1.png';
            const PLAYER_RUN2_IMAGE = 'run2.png';
            const PLAYER_RUN3_IMAGE = 'run3.png';
            // ==============================================

            // Загружаем все изображения
            const playerImages = {
                idle: new Image(),
                run: [
                    new Image(), // run1
                    new Image(), // run2
                    new Image()  // run3
                ]
            };

            playerImages.idle.src = PLAYER_IDLE_IMAGE;
            playerImages.run[0].src = PLAYER_RUN1_IMAGE;
            playerImages.run[1].src = PLAYER_RUN2_IMAGE;
            playerImages.run[2].src = PLAYER_RUN3_IMAGE;

            // Игрок (начальные размеры - стоячего)
            let player = {
                x: (WORLD_PIXEL_WIDTH - IDLE_WIDTH) / 2,
                y: (WORLD_PIXEL_HEIGHT - IDLE_HEIGHT) / 2,
                vx: 0,
                vy: 0,
                speed: 0.5,
                facing: 1,
                width: IDLE_WIDTH,
                height: IDLE_HEIGHT,
                isMoving: false
            };

            // Переменные для анимации
            let animationFrame = 0;
            const ANIMATION_SPEED = 8;
            let frameCounter = 0;

            // Генерация типа тайла
            function getTileType(x, y) {
                const noise = Math.sin(x * 0.05) * Math.cos(y * 0.05);
                if (noise > 0.3) return 'grass';
                if (noise < -0.3) return 'sand';
                return 'dirt';
            }

            const TILE_COLORS = {
                grass: '#4A7C59',
                sand: '#C2B280',
                dirt: '#8B7355'
            };

            // Отрисовка фона
            function drawBackground() {
                const grad = ctx.createLinearGradient(0, 0, 0, WORLD_PIXEL_HEIGHT * 0.3);
                grad.addColorStop(0, '#87CEEB');
                grad.addColorStop(1, '#B0E0E6');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, WORLD_PIXEL_WIDTH, WORLD_PIXEL_HEIGHT * 0.3);

                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        const type = getTileType(x, y);
                        ctx.fillStyle = TILE_COLORS[type];
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            // Отрисовка игрока с разными размерами для разных состояний
            function drawPlayer() {
                let currentImage;
                let currentWidth, currentHeight;

                if (player.isMoving) {
                    // Бег - используем размеры для бега
                    currentWidth = RUN_WIDTH;
                    currentHeight = RUN_HEIGHT;

                    frameCounter++;
                    if (frameCounter >= ANIMATION_SPEED) {
                        frameCounter = 0;
                        animationFrame = (animationFrame + 1) % 3;
                    }
                    currentImage = playerImages.run[animationFrame];
                } else {
                    // Стоя - используем размеры для стояния
                    currentWidth = IDLE_WIDTH;
                    currentHeight = IDLE_HEIGHT;
                    currentImage = playerImages.idle;
                }

                // Обновляем размеры игрока (для коллизий)
                player.width = currentWidth;
                player.height = currentHeight;

                if (currentImage && currentImage.complete && currentImage.naturalHeight !== 0) {
                    ctx.save();

                    if (player.facing === -1) {
                        // При движении влево отражаем
                        ctx.translate(player.x + currentWidth, player.y);
                        ctx.scale(-1, 1);
                        ctx.drawImage(currentImage, 0, 0, currentWidth, currentHeight);
                    } else {
                        ctx.drawImage(currentImage, player.x, player.y, currentWidth, currentHeight);
                    }

                    ctx.restore();

                    // Опционально: отладочные рамки
                    // ctx.strokeStyle = player.isMoving ? '#ff0000' : '#00ff00';
                    // ctx.lineWidth = 1;
                    // ctx.strokeRect(player.x, player.y, currentWidth, currentHeight);

                } else {
                    // Отладочный квадрат
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(player.x, player.y, currentWidth, currentHeight);

                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px Arial';
                    ctx.fillText(
                        player.isMoving ? `RUN:${currentWidth}x${currentHeight}` : `IDLE:${currentWidth}x${currentHeight}`,
                        player.x,
                        player.y - 5
                    );
                }
            }

            // Обновление физики
            function update() {
                const prevVx = player.vx;
                const prevVy = player.vy;

                // Сохраняем текущие размеры для проверки границ
                const currentWidth = player.isMoving ? RUN_WIDTH : IDLE_WIDTH;
                const currentHeight = player.isMoving ? RUN_HEIGHT : IDLE_HEIGHT;

                player.x += player.vx;
                player.y += player.vy;

                // Границы с учетом текущих размеров
                player.x = Math.max(0, Math.min(WORLD_PIXEL_WIDTH - currentWidth, player.x));
                player.y = Math.max(0, Math.min(WORLD_PIXEL_HEIGHT - currentHeight, player.y));

                player.vx *= 0.8;
                player.vy *= 0.8;
                if (Math.abs(player.vx) < 0.1) player.vx = 0;
                if (Math.abs(player.vy) < 0.1) player.vy = 0;

                // Проверка движения
                const wasMoving = player.isMoving;
                player.isMoving = (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1);

                // Направление
                if (player.vx !== 0) player.facing = player.vx > 0 ? 1 : -1;

                // При смене состояния (остановка) корректируем позицию
                if (wasMoving && !player.isMoving) {
                    // Переход из бега в стойку - центрируем по X для нового размера
                    const centerX = player.x + RUN_WIDTH / 2;
                    player.x = centerX - IDLE_WIDTH / 2;

                    // Корректируем границы
                    player.x = Math.max(0, Math.min(WORLD_PIXEL_WIDTH - IDLE_WIDTH, player.x));

                    animationFrame = 0;
                    frameCounter = 0;
                }

                // При старте бега корректируем позицию
                if (!wasMoving && player.isMoving) {
                    // Переход из стойки в бег - центрируем по X для нового размера
                    const centerX = player.x + IDLE_WIDTH / 2;
                    player.x = centerX - RUN_WIDTH / 2;

                    // Корректируем границы
                    player.x = Math.max(0, Math.min(WORLD_PIXEL_WIDTH - RUN_WIDTH, player.x));
                }
            }

            // Управление с клавиатуры
            const keys = {};
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                if (e.key.startsWith('Arrow')) {
                    const arrow = e.key.toLowerCase().replace('arrow','');
                    keys[arrow] = true;
                }
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
                    e.preventDefault();
                }
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = false;
                if (e.key.startsWith('Arrow')) {
                    const arrow = e.key.toLowerCase().replace('arrow','');
                    keys[arrow] = false;
                }
            });

            function handleKeyboard() {
                let dx = 0, dy = 0;
                if (keys['a'] || keys['left']) dx -= 1;
                if (keys['d'] || keys['right']) dx += 1;
                if (keys['w'] || keys['up']) dy -= 1;
                if (keys['s'] || keys['down']) dy += 1;
                if (dx !== 0 || dy !== 0) {
                    const len = Math.sqrt(dx*dx + dy*dy);
                    const targetSpeed = player.speed * 5;
                    player.vx = (dx / len) * targetSpeed;
                    player.vy = (dy / len) * targetSpeed;
                }
            }

            // Джойстик
            let joystick = null;
            const joystickZone = document.getElementById('joystickZone');

            function initJoystick() {
                if (joystick) joystick.destroy();
                if (typeof nipplejs !== 'undefined') {
                    joystick = nipplejs.create({
                        zone: joystickZone,
                        mode: 'static',
                        position: { left: '50%', bottom: '50%' },
                        color: 'white',
                        size: 120,
                        threshold: 0.1,
                        lockY: false,
                        lockX: false
                    });

                    joystick.on('move', (evt, data) => {
                        if (data.vector) {
                            const targetSpeed = player.speed * 5;
                            player.vx = data.vector.x * targetSpeed;
                            player.vy = -data.vector.y * targetSpeed;
                        }
                    });

                    joystick.on('end', () => {
                        player.vx = 0;
                        player.vy = 0;
                    });
                }
            }

            function resizeCanvas() {
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
            }

            function checkOrientation() {
                if (window.innerWidth < window.innerHeight && window.matchMedia("(max-width: 768px)").matches) {
                    return false;
                } else {
                    document.body.style.display = 'flex';
                    if (screen.orientation && screen.orientation.lock) {
                        document.documentElement.requestFullscreen().then(() => {
                            screen.orientation.lock('landscape').catch(() => {});
                        }).catch(() => {});
                    }
                    return true;
                }
            }

            function init() {
                resizeCanvas();
                if (!checkOrientation()) return;
                initJoystick();

                window.addEventListener('resize', () => {
                    resizeCanvas();
                    checkOrientation();
                });

                gameLoop();
                setInterval(handleKeyboard, 16);
            }

            function gameLoop() {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                const scale = Math.min(canvasWidth / WORLD_PIXEL_WIDTH, canvasHeight / WORLD_PIXEL_HEIGHT);
                const offsetX = (canvasWidth - WORLD_PIXEL_WIDTH * scale) / 2;
                const offsetY = (canvasHeight - WORLD_PIXEL_HEIGHT * scale) / 2;

                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);

                drawBackground();
                update();
                drawPlayer();

                ctx.restore();
                requestAnimationFrame(gameLoop);
            }

            window.addEventListener('load', init);

            if (document.readyState === 'complete') {
                init();
            } else {
                window.addEventListener('load', init);
            }

        })();
    </script>
</body>
</html>
