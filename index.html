<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Soul Knight Base</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100vh; 
            height: 100dvh; /* modern browsers */
            touch-action: none;
            position: fixed;
            top: 0;
            left: 0;
            object-fit: cover;
        }
        #orientationMessage {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            color: white;
            font-size: 24px;
            text-align: center;
            background: black;
            z-index: 1000;
        }
        #rotateButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="orientationMessage">Переверните устройство в горизонтальное положение для игры.</div>
    <canvas id="gameCanvas"></canvas>
    <script>
        // Интеграция с Telegram Web App — максимально возможное скрытие/прозрачность header и bottom bar
        let isTelegram = false;
        let tg;
        let fullscreenRequested = false;
        if (window.Telegram && window.Telegram.WebApp) {
            isTelegram = true;
            tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand(); // Расширяем по высоте (важно для всех версий)
            tg.disableClosingConfirmation(); // Отключаем подтверждение закрытия (с Bot API 6.2+)
           
            // Проверяем версию Bot API для поддержки методов
            const tgVersion = parseFloat(tg.version) || 0;
           
            // Устанавливаем цвет header для слияния/невидимости (с Bot API 6.1+)
            if (tgVersion >= 6.1) {
                tg.setHeaderColor('bg_color'); // Сливаем с фоном, делая header невидимым
                tg.setBackgroundColor('#000000'); // Черный фон
            }
           
            // Для bottom bar: устанавливаем цвет и скрываем кнопки (с Bot API 7.10+ для setBottomBarColor и SecondaryButton)
            if (tgVersion >= 7.10) {
                tg.setBottomBarColor('bg_color'); // Сливаем bottom bar с фоном для невидимости
            }
            tg.MainButton.hide(); // Скрываем MainButton (с Bot API 6.1+), это может скрыть bottom bar если он пустой
            if (tg.SecondaryButton && tgVersion >= 7.10) {
                tg.SecondaryButton.hide(); // Скрываем SecondaryButton
            }
           
            // Отключаем вертикальные свайпы (с Bot API 7.7+), чтобы не тянуть вниз и не показывать header
            if (tgVersion >= 7.7 && tg.disableVerticalSwipes) {
                tg.disableVerticalSwipes();
            }
           
            // Пытаемся fullscreen (с Bot API 8.0+), где header становится transparent
            const tryRequestFullscreen = () => {
                if (tgVersion >= 8.0 && tg.requestFullscreen) {
                    tg.requestFullscreen()
                        .then(() => {
                            console.log("Fullscreen enabled via Telegram API");
                            tg.expand(); // Повторно expand после fullscreen
                        })
                        .catch(err => {
                            console.log("Telegram fullscreen failed:", err);
                            // Fallback на браузерный fullscreen
                            if (document.documentElement.requestFullscreen) {
                                document.documentElement.requestFullscreen({ navigationUI: "hide" }).catch(fallbackErr => console.log("Browser fullscreen failed:", fallbackErr));
                            }
                        });
                } else {
                    // Fallback для старых версий: браузерный fullscreen
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen({ navigationUI: "hide" }).catch(err => console.log("Fullscreen failed:", err));
                    }
                }
            };
           
            // Слушаем события fullscreen
            if (tgVersion >= 8.0) {
                tg.onEvent('fullscreenChanged', () => {
                    if (tg.isFullscreen) {
                        console.log("Entered fullscreen mode");
                    } else {
                        console.log("Exited fullscreen mode");
                        // Повторно запросить, если вышел
                        if (!fullscreenRequested) tryRequestFullscreen();
                    }
                });
                tg.onEvent('fullscreenFailed', (error) => {
                    console.log("Fullscreen failed:", error);
                    // Fallback на браузерный fullscreen при ошибке
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen({ navigationUI: "hide" }).catch(() => {});
                    }
                });
            }
           
            // Запрашиваем fullscreen при первом взаимодействии
            const requestFullscreenOnInteraction = () => {
                if (fullscreenRequested) return;
                fullscreenRequested = true;
                tryRequestFullscreen();
            };
           
        } else {
            // Если не в Telegram, сразу пытаемся fullscreen с скрытием навигации
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen({ navigationUI: "hide" }).catch(err => console.log("Fullscreen failed:", err));
            }
        }
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageDiv = document.getElementById('orientationMessage');
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || isTelegram;
        
        let SCREEN_WIDTH = window.innerWidth;
        let SCREEN_HEIGHT = window.innerHeight;
        
        // Game world variables
        let mapImg, charImg, mapLoaded = false, charLoaded = false;
        let MAP_WIDTH, MAP_HEIGHT;
        let originalMapWidth = 800, originalMapHeight = 600; // default until image loads
        let charWidth, charHeight;
        let charX, charY;
        let charSpeed = 300; // px/s - adjusted for better feel
        
        // Camera position
        let cameraX = 0, cameraY = 0;
        
        // Scale factor between screen and map
        let scaleX, scaleY;
        
        // Keyboard controls
        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        
        // Dynamic joystick (activates on left half of screen)
        let joystick = {
            active: false,
            centerX: 0,
            centerY: 0,
            currentX: 0,
            currentY: 0,
            touchId: null,
            radius: 60
        };
        
        let lastTime = 0;
        
        // Update screen dimensions
        function updateDimensions() {
            SCREEN_WIDTH = window.innerWidth;
            SCREEN_HEIGHT = window.innerHeight;
            canvas.width = SCREEN_WIDTH;
            canvas.height = SCREEN_HEIGHT;
            
            if (mapLoaded) {
                // Calculate scale to fit map to screen
                scaleX = SCREEN_WIDTH / originalMapWidth;
                scaleY = SCREEN_HEIGHT / originalMapHeight;
                
                // Use uniform scaling to preserve aspect ratio (fill screen)
                const scale = Math.max(scaleX, scaleY);
                
                MAP_WIDTH = originalMapWidth * scale;
                MAP_HEIGHT = originalMapHeight * scale;
                
                // Update character size proportionally
                if (charImg) {
                    charWidth = charImg.width * scale;
                    charHeight = charImg.height * scale;
                }
                
                // Adjust character position to stay within new bounds
                if (charX !== undefined) {
                    charX = Math.max(0, Math.min(charX, MAP_WIDTH - charWidth));
                    charY = Math.max(0, Math.min(charY, MAP_HEIGHT - charHeight));
                }
            }
        }
        
        // Load and start game
        async function startGame() {
            if (mapLoaded && charLoaded) return;
            
            // Load map image
            mapImg = new Image();
            mapImg.src = 'map.png';
            await new Promise(resolve => {
                mapImg.onload = () => {
                    originalMapWidth = mapImg.width;
                    originalMapHeight = mapImg.height;
                    mapLoaded = true;
                    updateDimensions();
                    resolve();
                };
                mapImg.onerror = () => {
                    // Use default dimensions if image fails to load
                    mapLoaded = true;
                    updateDimensions();
                    resolve();
                };
            });
            
            // Load character image
            charImg = new Image();
            charImg.src = 'character.png';
            await new Promise(resolve => {
                charImg.onload = () => {
                    charLoaded = true;
                    updateDimensions();
                    resolve();
                };
                charImg.onerror = () => {
                    charLoaded = true;
                    updateDimensions();
                    resolve();
                };
            });
            
            // Initialize character position (center of map)
            charX = MAP_WIDTH / 2 - charWidth / 2;
            charY = MAP_HEIGHT / 2 - charHeight / 2;
            
            // Initialize camera to follow character
            cameraX = charX + charWidth / 2 - SCREEN_WIDTH / 2;
            cameraY = charY + charHeight / 2 - SCREEN_HEIGHT / 2;
            clampCamera();
            
            // Set up event listeners for mobile
            if (isMobile) {
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
                canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            }
            
            // Fullscreen on first interaction
            canvas.addEventListener('touchstart', requestFullscreenOnInteraction, { once: true });
            canvas.addEventListener('click', requestFullscreenOnInteraction, { once: true });
            
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
        
        function clampCamera() {
            cameraX = Math.max(0, Math.min(cameraX, MAP_WIDTH - SCREEN_WIDTH));
            cameraY = Math.max(0, Math.min(cameraY, MAP_HEIGHT - SCREEN_HEIGHT));
        }
        
        function requestFullscreenOnInteraction() {
            if (fullscreenRequested) return;
            fullscreenRequested = true;
            if (isTelegram) {
                // Use the function defined earlier
                if (window.tryRequestFullscreen) tryRequestFullscreen();
            } else if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen({ navigationUI: "hide" })
                    .catch(err => console.log("Fullscreen failed:", err));
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            if (joystick.active) return;
            
            for (let touch of e.changedTouches) {
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Activate only on left half of screen
                if (touchX < SCREEN_WIDTH / 2) {
                    joystick.active = true;
                    joystick.centerX = touchX;
                    joystick.centerY = touchY;
                    joystick.currentX = touchX;
                    joystick.currentY = touchY;
                    joystick.touchId = touch.identifier;
                    break;
                }
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (!joystick.active) return;
            
            for (let touch of e.touches) {
                if (touch.identifier === joystick.touchId) {
                    const rect = canvas.getBoundingClientRect();
                    joystick.currentX = touch.clientX - rect.left;
                    joystick.currentY = touch.clientY - rect.top;
                    break;
                }
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            joystick.active = false;
            joystick.touchId = null;
        }
        
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const delta = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;
            
            const moveDelta = charSpeed * delta;
            
            // Keyboard movement
            if (keys['w'] || keys['arrowup']) charY -= moveDelta;
            if (keys['s'] || keys['arrowdown']) charY += moveDelta;
            if (keys['a'] || keys['arrowleft']) charX -= moveDelta;
            if (keys['d'] || keys['arrowright']) charX += moveDelta;
            
            // Joystick movement
            if (joystick.active) {
                let dx = joystick.currentX - joystick.centerX;
                let dy = joystick.currentY - joystick.centerY;
                let dist = Math.hypot(dx, dy);
                
                if (dist > 0.01) {
                    dx /= dist;
                    dy /= dist;
                    const power = Math.min(dist / joystick.radius, 1);
                    charX += dx * moveDelta * power * 1.5;
                    charY += dy * moveDelta * power * 1.5;
                }
            }
            
            // Clamp character to map bounds
            charX = Math.max(0, Math.min(charX, MAP_WIDTH - charWidth));
            charY = Math.max(0, Math.min(charY, MAP_HEIGHT - charHeight));
            
            // Update camera to follow character
            let targetCameraX = charX + charWidth / 2 - SCREEN_WIDTH / 2;
            let targetCameraY = charY + charHeight / 2 - SCREEN_HEIGHT / 2;
            
            // Smooth camera movement
            const lerpFactor = 0.1;
            cameraX += (targetCameraX - cameraX) * lerpFactor;
            cameraY += (targetCameraY - cameraY) * lerpFactor;
            
            clampCamera();
            
            // Clear screen
            ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            
            // Draw map (fills entire screen)
            if (mapLoaded) {
                ctx.drawImage(mapImg, -cameraX, -cameraY, MAP_WIDTH, MAP_HEIGHT);
            } else {
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Загрузка карты...', SCREEN_WIDTH/2, SCREEN_HEIGHT/2);
            }
            
            // Draw character
            const screenCharX = charX - cameraX;
            const screenCharY = charY - cameraY;
            
            if (charLoaded) {
                ctx.drawImage(charImg, screenCharX, screenCharY, charWidth, charHeight);
            } else {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(screenCharX, screenCharY, charWidth, charHeight);
            }
            
            // Draw joystick on mobile
            if (isMobile && joystick.active) {
                ctx.fillStyle = 'rgba(200,200,200,0.35)';
                ctx.beginPath();
                ctx.arc(joystick.centerX, joystick.centerY, joystick.radius * 1.6, 0, Math.PI * 2);
                ctx.fill();
                
                let dx = joystick.currentX - joystick.centerX;
                let dy = joystick.currentY - joystick.centerY;
                let dist = Math.hypot(dx, dy);
                
                if (dist > joystick.radius) {
                    dx = dx / dist * joystick.radius;
                    dy = dy / dist * joystick.radius;
                }
                
                ctx.fillStyle = 'rgba(100,100,100,0.75)';
                ctx.beginPath();
                ctx.arc(joystick.centerX + dx, joystick.centerY + dy, joystick.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Handle resize events
        window.addEventListener('resize', () => {
            updateDimensions();
            clampCamera();
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                updateDimensions();
                clampCamera();
            }, 100);
        });
        
        // Always hide orientation message - we want fullscreen always
        messageDiv.style.display = 'none';
        
        // Start the game
        startGame();
        
        // Try fullscreen on desktop immediately
        if (!isMobile && document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen({ navigationUI: "hide" }).catch(() => {});
        }
        
        // Fix for Telegram
        if (isTelegram) {
            window.tryRequestFullscreen = tryRequestFullscreen;
        }
    </script>
</body>
</html>
