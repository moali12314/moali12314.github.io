<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Soul Knight - Horizontal Fullscreen</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
       
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: #000;
        }
       
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: pan-y pinch-zoom;
        }
       
        /* Блокировка вертикальной ориентации на телефонах */
        @media (max-width: 768px) and (orientation: portrait) {
            body::before {
                content: "ПОВЕРНИТЕ ЭКРАН";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: white;
                font-size: 24px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                z-index: 9999;
                font-family: Arial, sans-serif;
                letter-spacing: 2px;
            }
            canvas, #joystickZone {
                display: none !important;
            }
        }
       
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: fill; /* Растягиваем четко по размерам */
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
       
        /* Джойстик всегда виден в горизонтальной ориентации */
        #joystickZone {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 130px;
            height: 130px;
            z-index: 100;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(4px);
            border: 2px solid rgba(255,255,255,0.3);
            display: block;
            touch-action: none;
            pointer-events: auto;
        }
       
        /* Скрываем любой старый UI */
        #ui {
            display: none !important;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="joystickZone"></div>
    <script>
        (function() {
            // Telegram Web App
            if (window.Telegram?.WebApp) {
                Telegram.WebApp.ready();
                Telegram.WebApp.expand();
                Telegram.WebApp.setHeaderColor?.('#000000');
            }
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            // Фиксированный размер тайла
            const TILE_SIZE = 32;
           
            // Переменные для размеров canvas
            let canvasWidth, canvasHeight;
            let WORLD_WIDTH = 200; // Широкий горизонтальный мир (в тайлах)
            let WORLD_HEIGHT;
            // Камера
            let camera = { x: 0, y: 0 };
            // Игрок
            let player = {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                speed: 1.5, // базовая скорость
                facing: 1,
                size: TILE_SIZE
            };
            // Цвета персонажа
            const COLORS = {
                skin: [255, 204, 153, 255],
                shirt: [255, 0, 0, 255],
                pants: [0, 0, 255, 255],
                shoes: [0, 0, 0, 255],
                hair: [0, 0, 0, 255]
            };
            // Функция для установки пикселя
            function setPixel(pixels, x, y, color) {
                const idx = (Math.floor(y) * TILE_SIZE + Math.floor(x)) * 4;
                if (idx >= 0 && idx < pixels.length) {
                    pixels[idx] = color[0];
                    pixels[idx+1] = color[1];
                    pixels[idx+2] = color[2];
                    pixels[idx+3] = color[3];
                }
            }
            // Создание спрайта игрока
            function createPlayerSprite(isRightFacing = true) {
                const pixels = new Uint8ClampedArray(TILE_SIZE * TILE_SIZE * 4).fill(0);
                const flipX = (x) => isRightFacing ? x : TILE_SIZE - 1 - x;
                // Голова
                for (let dx = -8; dx <= 8; dx++) {
                    for (let dy = -4; dy <= 6; dy++) {
                        if (Math.abs(dx/8) + Math.abs(dy/6) < 1) {
                            setPixel(pixels, flipX(16 + dx), 4 + dy, COLORS.skin);
                        }
                    }
                }
                // Волосы
                for (let dx = -6; dx <= 6; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        if (Math.abs(dx/6) + Math.abs(dy/2) < 1) {
                            setPixel(pixels, flipX(16 + dx), 2 + dy, COLORS.hair);
                        }
                    }
                }
                // Тело
                for (let dx = -7; dx <= 7; dx++) {
                    let height = 13 - Math.abs(dx);
                    for (let dy = 0; dy < height; dy++) {
                        setPixel(pixels, flipX(16 + dx), 10 + dy, COLORS.shirt);
                    }
                }
                // Руки
                for (let dy = 0; dy < 9; dy++) {
                    setPixel(pixels, flipX(9), 11 + dy, COLORS.skin);
                    setPixel(pixels, flipX(10), 11 + dy, COLORS.skin);
                    setPixel(pixels, flipX(22), 11 + dy, COLORS.skin);
                    setPixel(pixels, flipX(23), 11 + dy, COLORS.skin);
                }
                // Ноги
                for (let dy = 0; dy < 12; dy++) {
                    setPixel(pixels, flipX(14), 22 + dy, COLORS.pants);
                    setPixel(pixels, flipX(15), 22 + dy, COLORS.pants);
                    setPixel(pixels, flipX(18), 22 + dy, COLORS.pants);
                    setPixel(pixels, flipX(19), 22 + dy, COLORS.pants);
                }
                for (let dy = 8; dy < 12; dy++) {
                    setPixel(pixels, flipX(15), 26 + dy, COLORS.shoes);
                    setPixel(pixels, flipX(16), 26 + dy, COLORS.shoes);
                    setPixel(pixels, flipX(19), 26 + dy, COLORS.shoes);
                    setPixel(pixels, flipX(20), 26 + dy, COLORS.shoes);
                }
                return new ImageData(pixels, TILE_SIZE, TILE_SIZE);
            }
            // Генерация типа тайла
            function getTileType(x, y) {
                const noise = Math.sin(x * 0.05) * Math.cos(y * 0.05);
                if (noise > 0.3) return 'grass';
                if (noise < -0.3) return 'sand';
                return 'dirt';
            }
            const TILE_COLORS = {
                grass: '#4A7C59',
                sand: '#C2B280',
                dirt: '#8B7355'
            };
            // Отрисовка фона (карты)
            function drawBackground() {
                // Градиент неба (фиксированный, не скроллится)
                const grad = ctx.createLinearGradient(0, 0, 0, canvasHeight * 0.3);
                grad.addColorStop(0, '#87CEEB');
                grad.addColorStop(1, '#B0E0E6');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight * 0.3);
                // Тайлы - горизонтальная карта с камерой (скролл только по X)
                const startX = Math.floor(camera.x / TILE_SIZE);
                const endX = startX + Math.ceil(canvasWidth / TILE_SIZE) + 1;
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    for (let x = startX; x < endX; x++) {
                        if (x < 0 || x >= WORLD_WIDTH) continue;
                        const type = getTileType(x, y);
                        ctx.fillStyle = TILE_COLORS[type];
                        ctx.fillRect((x * TILE_SIZE) - camera.x, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
            // Отрисовка игрока
            function drawPlayer() {
                const sprite = createPlayerSprite(player.facing === 1);
                ctx.putImageData(sprite, player.x - camera.x, player.y);
            }
            // Обновление физики
            function update() {
                player.x += player.vx;
                player.y += player.vy;
                // Границы карты (горизонтальный скролл, вертикальный фиксирован)
                player.x = Math.max(0, Math.min((WORLD_WIDTH * TILE_SIZE) - player.size, player.x));
                player.y = Math.max(0, Math.min(canvasHeight - player.size, player.y));
                // Обновление камеры (только по X, следует за игроком)
                camera.x = player.x - (canvasWidth / 2) + (player.size / 2);
                camera.x = Math.max(0, Math.min((WORLD_WIDTH * TILE_SIZE) - canvasWidth, camera.x));
                // Трение
                player.vx *= 0.8;
                player.vy *= 0.8;
                if (Math.abs(player.vx) < 0.1) player.vx = 0;
                if (Math.abs(player.vy) < 0.1) player.vy = 0;
                if (player.vx !== 0) player.facing = player.vx > 0 ? 1 : -1;
            }
            // Управление с клавиатуры (для ПК)
            const keys = {};
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                if (e.key.startsWith('Arrow')) {
                    const arrow = e.key.toLowerCase().replace('arrow','');
                    keys[arrow] = true;
                }
                // Блокируем скролл страницы на стрелках
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
                    e.preventDefault();
                }
            });
           
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = false;
                if (e.key.startsWith('Arrow')) {
                    const arrow = e.key.toLowerCase().replace('arrow','');
                    keys[arrow] = false;
                }
            });
            function handleKeyboard() {
                let dx = 0, dy = 0;
                if (keys['a'] || keys['left']) dx -= 1;
                if (keys['d'] || keys['right']) dx += 1;
                if (keys['w'] || keys['up']) dy -= 1;
                if (keys['s'] || keys['down']) dy += 1;
                if (dx !== 0 || dy !== 0) {
                    const len = Math.sqrt(dx*dx + dy*dy);
                    const targetSpeed = player.speed * 5;
                    player.vx = (dx / len) * targetSpeed;
                    player.vy = (dy / len) * targetSpeed;
                }
            }
            // Джойстик
            let joystick = null;
            const joystickZone = document.getElementById('joystickZone');
           
            function initJoystick() {
                if (joystick) joystick.destroy();
                if (typeof nipplejs !== 'undefined') {
                    joystick = nipplejs.create({
                        zone: joystickZone,
                        mode: 'static',
                        position: { left: '50%', bottom: '50%' },
                        color: 'white',
                        size: 120,
                        threshold: 0.1,
                        lockY: false,
                        lockX: false
                    });
                   
                    joystick.on('move', (evt, data) => {
                        if (data.vector) {
                            const targetSpeed = player.speed * 5;
                            player.vx = data.vector.x * targetSpeed;
                            player.vy = -data.vector.y * targetSpeed;
                        }
                    });
                   
                    joystick.on('end', () => {
                        player.vx = 0;
                        player.vy = 0;
                    });
                }
            }
            // Ресайз canvas под текущий экран (всегда горизонтальный)
            function resizeCanvas() {
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;
               
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                // Высота мира фиксирована по экрану, ширина большая
                WORLD_HEIGHT = Math.ceil(canvasHeight / TILE_SIZE);
                // Центрируем игрока по Y, старт по X
                player.x = Math.floor((canvasWidth - player.size) / 2);
                player.y = Math.floor((canvasHeight - player.size) / 2);
            }
            // Проверка ориентации
            function checkOrientation() {
                // На мобильных устройствах проверяем портретную ориентацию
                if (window.innerWidth < window.innerHeight && window.matchMedia("(max-width: 768px)").matches) {
                    // Портрет - ничего не делаем, CSS покажет сообщение
                    return false;
                } else {
                    // Альбом - включаем отображение
                    document.body.style.display = 'flex';
                    // Попытка заблокировать ориентацию в landscape (работает только в fullscreen)
                    if (screen.orientation && screen.orientation.lock) {
                        document.documentElement.requestFullscreen().then(() => {
                            screen.orientation.lock('landscape').catch(() => {});
                        }).catch(() => {});
                    }
                    return true;
                }
            }
            // Инициализация
            function init() {
                resizeCanvas();
                if (!checkOrientation()) return; // Если портрет, не инициализируем
                initJoystick();
               
                // Слушаем изменения размера (поворот)
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    checkOrientation();
                });
               
                // Запуск игрового цикла
                gameLoop();
               
                // Периодический опрос клавиатуры
                setInterval(handleKeyboard, 16);
               
                // Удаляем старый UI
                const oldUi = document.getElementById('ui');
                if (oldUi) oldUi.remove();
            }
            // Игровой цикл
            function gameLoop() {
                drawBackground();
                update();
                drawPlayer();
                requestAnimationFrame(gameLoop);
            }
            // Стартуем после загрузки
            window.addEventListener('load', init);
           
            // Для Telegram запускаем сразу
            if (document.readyState === 'complete') {
                init();
            } else {
                window.addEventListener('load', init);
            }
           
        })();
    </script>
</body>
</html>
